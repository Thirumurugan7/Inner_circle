import { concatHex, encodeFunctionData, toHex, zeroAddress } from "viem";
import { entryPoint06Abi, entryPoint07Abi, entryPoint07Address, getUserOperationHash, toSmartAccount } from "viem/account-abstraction";
import { signMessage as _signMessage, getChainId } from "viem/actions";
import { getAction } from "viem/utils";
import { getAccountNonce } from "../../actions/public/getAccountNonce.js";
import { getSenderAddress } from "../../actions/public/getSenderAddress.js";
import { toOwner } from "../../utils/toOwner.js";
import { KernelInitAbi } from "./abi/KernelAccountAbi.js";
import { KernelV3InitAbi, KernelV3_1AccountAbi } from "./abi/KernelV3AccountAbi.js";
import { KernelV3MetaFactoryDeployWithFactoryAbi } from "./abi/KernelV3MetaFactoryAbi.js";
import { DUMMY_ECDSA_SIGNATURE, ROOT_MODE_KERNEL_V2, VALIDATOR_TYPE } from "./constants.js";
import { encodeCallData } from "./utils/encodeCallData.js";
import { getNonceKeyWithEncoding } from "./utils/getNonceKey.js";
import { isKernelV2 } from "./utils/isKernelV2.js";
import { signMessage } from "./utils/signMessage.js";
import { signTypedData } from "./utils/signTypedData.js";
/**
 * The account creation ABI for a kernel smart account (from the KernelFactory)
 */
const createAccountAbi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_implementation",
                type: "address"
            },
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256"
            }
        ],
        name: "createAccount",
        outputs: [
            {
                internalType: "address",
                name: "proxy",
                type: "address"
            }
        ],
        stateMutability: "payable",
        type: "function"
    }
];
/**
 * Default addresses map for different kernel smart account versions
 */
export const KERNEL_VERSION_TO_ADDRESSES_MAP = {
    "0.2.1": {
        ECDSA_VALIDATOR: "0xd9AB5096a832b9ce79914329DAEE236f8Eea0390",
        ACCOUNT_LOGIC: "0xf048AD83CB2dfd6037A43902a2A5Be04e53cd2Eb",
        FACTORY_ADDRESS: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3"
    },
    "0.2.2": {
        ECDSA_VALIDATOR: "0xd9AB5096a832b9ce79914329DAEE236f8Eea0390",
        ACCOUNT_LOGIC: "0x0DA6a956B9488eD4dd761E59f52FDc6c8068E6B5",
        FACTORY_ADDRESS: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3"
    },
    "0.2.3": {
        ECDSA_VALIDATOR: "0xd9AB5096a832b9ce79914329DAEE236f8Eea0390",
        ACCOUNT_LOGIC: "0xD3F582F6B4814E989Ee8E96bc3175320B5A540ab",
        FACTORY_ADDRESS: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3"
    },
    "0.2.4": {
        ECDSA_VALIDATOR: "0xd9AB5096a832b9ce79914329DAEE236f8Eea0390",
        ACCOUNT_LOGIC: "0xd3082872F8B06073A021b4602e022d5A070d7cfC",
        FACTORY_ADDRESS: "0x5de4839a76cf55d0c90e2061ef4386d962E15ae3"
    },
    "0.3.0-beta": {
        ECDSA_VALIDATOR: "0x8104e3Ad430EA6d354d013A6789fDFc71E671c43",
        ACCOUNT_LOGIC: "0x94F097E1ebEB4ecA3AAE54cabb08905B239A7D27",
        FACTORY_ADDRESS: "0x6723b44Abeec4E71eBE3232BD5B455805baDD22f",
        META_FACTORY_ADDRESS: "0xd703aaE79538628d27099B8c4f621bE4CCd142d5"
    },
    "0.3.1": {
        ECDSA_VALIDATOR: "0x845ADb2C711129d4f3966735eD98a9F09fC4cE57",
        ACCOUNT_LOGIC: "0xBAC849bB641841b44E965fB01A4Bf5F074f84b4D",
        FACTORY_ADDRESS: "0xaac5D4240AF87249B3f71BC8E4A2cae074A3E419",
        META_FACTORY_ADDRESS: "0xd703aaE79538628d27099B8c4f621bE4CCd142d5"
    }
};
/**
 * Get supported Kernel Smart Account version based on entryPoint
 * @param entryPoint
 */
const getDefaultKernelVersion = (entryPointVersion, version) => {
    if (version) {
        return version;
    }
    return (entryPointVersion === "0.6" ? "0.2.2" : "0.3.0-beta");
};
/**
 * Get default addresses for Kernel Smart Account based on entryPoint or user input
 * @param entryPointAddress
 * @param ecdsaValidatorAddress
 * @param accountLogicAddress
 * @param factoryAddress
 * @param metaFactoryAddress
 */
const getDefaultAddresses = ({ ecdsaValidatorAddress: _ecdsaValidatorAddress, accountLogicAddress: _accountLogicAddress, factoryAddress: _factoryAddress, metaFactoryAddress: _metaFactoryAddress, kernelVersion }) => {
    const addresses = KERNEL_VERSION_TO_ADDRESSES_MAP[kernelVersion];
    const ecdsaValidatorAddress = _ecdsaValidatorAddress ?? addresses.ECDSA_VALIDATOR;
    const accountLogicAddress = _accountLogicAddress ?? addresses.ACCOUNT_LOGIC;
    const factoryAddress = _factoryAddress ?? addresses.FACTORY_ADDRESS;
    const metaFactoryAddress = _metaFactoryAddress ?? addresses?.META_FACTORY_ADDRESS ?? zeroAddress; // Meta Factory doesn't exists for Kernel v2.2
    return {
        ecdsaValidatorAddress,
        accountLogicAddress,
        factoryAddress,
        metaFactoryAddress
    };
};
export const getEcdsaRootIdentifierForKernelV3 = (validatorAddress) => {
    return concatHex([VALIDATOR_TYPE.VALIDATOR, validatorAddress]);
};
/**
 * Get the initialization data for a kernel smart account
 * @param entryPoint
 * @param owner
 * @param ecdsaValidatorAddress
 */
const getInitializationData = ({ entryPoint: { version: entryPointVersion }, kernelVersion, owner, ecdsaValidatorAddress }) => {
    if (entryPointVersion === "0.6") {
        return encodeFunctionData({
            abi: KernelInitAbi,
            functionName: "initialize",
            args: [ecdsaValidatorAddress, owner]
        });
    }
    if (kernelVersion === "0.3.0-beta") {
        return encodeFunctionData({
            abi: KernelV3InitAbi,
            functionName: "initialize",
            args: [
                getEcdsaRootIdentifierForKernelV3(ecdsaValidatorAddress),
                zeroAddress,
                owner,
                "0x"
            ]
        });
    }
    return encodeFunctionData({
        abi: KernelV3_1AccountAbi,
        functionName: "initialize",
        args: [
            getEcdsaRootIdentifierForKernelV3(ecdsaValidatorAddress),
            zeroAddress,
            owner,
            "0x",
            []
        ]
    });
};
/**
 * Get the account initialization code for a kernel smart account
 * @param entryPoint
 * @param owner
 * @param index
 * @param factoryAddress
 * @param accountLogicAddress
 * @param ecdsaValidatorAddress
 */
const getAccountInitCode = async ({ entryPointVersion, kernelVersion, owner, index, factoryAddress, accountLogicAddress, ecdsaValidatorAddress }) => {
    // Build the account initialization data
    const initializationData = getInitializationData({
        entryPoint: { version: entryPointVersion },
        kernelVersion,
        ecdsaValidatorAddress,
        owner
    });
    // Build the account init code
    if (entryPointVersion === "0.6") {
        return encodeFunctionData({
            abi: createAccountAbi,
            functionName: "createAccount",
            args: [accountLogicAddress, initializationData, index]
        });
    }
    return encodeFunctionData({
        abi: KernelV3MetaFactoryDeployWithFactoryAbi,
        functionName: "deployWithFactory",
        args: [factoryAddress, initializationData, toHex(index, { size: 32 })]
    });
};
/**
 * Build a kernel smart account from a private key, that use the ECDSA signer behind the scene
 * @param client
 * @param privateKey
 * @param entryPoint
 * @param index
 * @param factoryAddress
 * @param accountLogicAddress
 * @param ecdsaValidatorAddress
 */
export async function toEcdsaKernelSmartAccount(parameters) {
    const { client, address, index = 0n, owners, version, ecdsaValidatorAddress: _ecdsaValidatorAddress, factoryAddress: _factoryAddress, metaFactoryAddress: _metaFactoryAddress, accountLogicAddress: _accountLogicAddress } = parameters;
    const localOwner = await toOwner({ owner: owners[0] });
    const entryPoint = {
        address: parameters.entryPoint?.address ?? entryPoint07Address,
        abi: (parameters.entryPoint?.version ?? "0.7") === "0.6"
            ? entryPoint06Abi
            : entryPoint07Abi,
        version: parameters.entryPoint?.version ?? "0.7"
    };
    const kernelVersion = getDefaultKernelVersion(entryPoint.version, version);
    const { accountLogicAddress, ecdsaValidatorAddress, factoryAddress, metaFactoryAddress } = getDefaultAddresses({
        ecdsaValidatorAddress: _ecdsaValidatorAddress,
        accountLogicAddress: _accountLogicAddress,
        factoryAddress: _factoryAddress,
        metaFactoryAddress: _metaFactoryAddress,
        kernelVersion
    });
    // Helper to generate the init code for the smart account
    const generateInitCode = () => getAccountInitCode({
        entryPointVersion: entryPoint.version,
        kernelVersion,
        owner: localOwner.address,
        index,
        factoryAddress,
        accountLogicAddress,
        ecdsaValidatorAddress
    });
    let accountAddress = address;
    let chainId;
    const getMemoizedChainId = async () => {
        if (chainId)
            return chainId;
        chainId = client.chain
            ? client.chain.id
            : await getAction(client, getChainId, "getChainId")({});
        return chainId;
    };
    const getFactoryArgs = async () => {
        return {
            factory: entryPoint.version === "0.6"
                ? factoryAddress
                : metaFactoryAddress,
            factoryData: await generateInitCode()
        };
    };
    return toSmartAccount({
        client,
        entryPoint,
        getFactoryArgs,
        async getAddress() {
            if (accountAddress)
                return accountAddress;
            const { factory, factoryData } = await getFactoryArgs();
            // Get the sender address based on the init code
            accountAddress = await getSenderAddress(client, {
                factory,
                factoryData,
                entryPointAddress: entryPoint.address
            });
            return accountAddress;
        },
        async encodeCalls(calls) {
            return encodeCallData({ calls, kernelVersion });
        },
        async getNonce(_args) {
            return getAccountNonce(client, {
                address: await this.getAddress(),
                entryPointAddress: entryPoint.address,
                key: getNonceKeyWithEncoding(kernelVersion, ecdsaValidatorAddress, 
                /*args?.key ?? */ parameters.nonceKey ?? 0n)
            });
        },
        async getStubSignature() {
            if (isKernelV2(kernelVersion)) {
                return concatHex([ROOT_MODE_KERNEL_V2, DUMMY_ECDSA_SIGNATURE]);
            }
            return DUMMY_ECDSA_SIGNATURE;
        },
        async sign({ hash }) {
            return this.signMessage({ message: hash });
        },
        async signMessage({ message }) {
            const signature = await signMessage({
                owner: localOwner,
                message,
                accountAddress: await this.getAddress(),
                kernelVersion,
                chainId: await getMemoizedChainId()
            });
            if (isKernelV2(kernelVersion)) {
                return signature;
            }
            return concatHex([
                getEcdsaRootIdentifierForKernelV3(ecdsaValidatorAddress),
                signature
            ]);
        },
        async signTypedData(typedData) {
            const signature = await signTypedData({
                owner: localOwner,
                chainId: await getMemoizedChainId(),
                ...typedData,
                accountAddress: await this.getAddress(),
                kernelVersion
            });
            if (isKernelV2(kernelVersion)) {
                return signature;
            }
            return concatHex([
                getEcdsaRootIdentifierForKernelV3(ecdsaValidatorAddress),
                signature
            ]);
        },
        // Sign a user operation
        async signUserOperation(parameters) {
            const { chainId = await getMemoizedChainId(), ...userOperation } = parameters;
            const hash = getUserOperationHash({
                userOperation: {
                    ...userOperation,
                    sender: userOperation.sender ?? (await this.getAddress()),
                    signature: "0x"
                },
                entryPointAddress: entryPoint.address,
                entryPointVersion: entryPoint.version,
                chainId: chainId
            });
            const signature = await localOwner.signMessage({
                message: { raw: hash }
            });
            // Always use the sudo mode, since we will use external paymaster
            if (isKernelV2(kernelVersion)) {
                return concatHex(["0x00000000", signature]);
            }
            return signature;
        }
    });
}
//# sourceMappingURL=toEcdsaKernelSmartAccount.js.map